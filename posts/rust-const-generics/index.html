<!DOCTYPE html>
<html class="dark light">

<!-- Copied over to allow our own lil bit of custom stuff -->

<head>

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180"    href ="https://peterkos.me/favicon/apple-touch-icon.png ">
    <link rel="icon" type="image/png" sizes="32x32" href ="https://peterkos.me/favicon/favicon-32x32.png ">
    <link rel="icon" type="image/png" sizes="16x16" href ="https://peterkos.me/favicon/favicon-16x16.png ">
    <link rel="manifest"                            href ="https://peterkos.me/favicon/site.webmanifest">
    <link rel="mask-icon"                           href ="https://peterkos.me/favicon/safari-pinned-tab.svg " color="#333333">
    <meta name="theme-color" content="#ffffff">

    <!-- Fontz -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,500;1,500&family=Fira+Code&family=Lato:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <script src="https://kit.fontawesome.com/342a374598.js" crossorigin="anonymous"></script>

    <!-- Custom code highlight styling -->
    <link rel="stylesheet" type="text/css" href="/syntax-theme-dark.css" media="(prefers-color-scheme: dark)" />
    <link rel="stylesheet" type="text/css" href="/syntax-theme-light.css" media="(prefers-color-scheme: light)" />

    <!-- From other file -->

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    

    
    
    
    <title>
         An O(1) Generic Blog Post About Rust
        
    </title>

        
            <meta property="og:title" content="An O(1) Generic Blog Post About Rust" />
        
     

     
         
     

     
         
    

    
    

    
    
        <link href=https://peterkos.me/fonts.css rel="stylesheet" />
    

    
    


    
        
            <script>
            MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };
            </script>
        
        <script type="text/javascript" id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>
    

    
    <link rel="alternate" type="application/atom+xml" title="Peter Kos" href="https://peterkos.me/atom.xml">


    
    
        <link rel="stylesheet" type="text/css" href=https://peterkos.me/theme/light.css />
        <link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://peterkos.me/theme/dark.css" />
    

    <link rel="stylesheet" type="text/css" media="screen" href=https://peterkos.me/main.css />

    
        
            <link rel="stylesheet" href="https://peterkos.me/custom.css">
        
    
</head>


<body>
    <div class="content">
        <header>
    
        <a href=https:&#x2F;&#x2F;peterkos.me id="title">Peter Kos</a>

        
        
    

    <nav>
        
            <a href=&#x2F;posts>&#x2F;posts</a>
        
            <a href=&#x2F;projects>&#x2F;projects</a>
        
            <a href=&#x2F;about>&#x2F;about</a>
        

        
        <a id="dark-mode-toggle" onclick="toggleTheme()" href="javascript:void(0)">
            <img src="/feather/sun.svg" id="sun-icon" style="filter: invert(1);" />
            <img src="/feather/moon.svg" id="moon-icon" />
        </a>
        <script src=https://peterkos.me/js/themetoggle.js></script>
        
    </nav>
</header>


        
        
    
<main>
    <article>
        <div class="title">
            
            
    <div class="page-header">
        An O(1) Generic Blog Post About Rust
        <!-- <span class="primary-color" style="font-size: 1.6em">.</span> -->
    </div>


                <div class="meta">
                    
                        Posted on <time>Apr 17, 2022</time>
                    

                    
                </div>
        </div>

        

        
        

        <section class="body">
            <p><em>Topics include: generics, const generics, monomorphization, macros, and GitHub archaeology</em></p>
<span id="continue-reading"></span>
<p><em>Credit goes to Prof. Matthew Fluet's <a href="https://www.cs.rit.edu/~mtf/teaching/20215/psr/">Programming Skills: Rust class</a> at RIT for the Rust knowledge, and more directly, the assignment to write a blog post on advanced Rust. I'll be writing another post soon about what it's like to learn Rust in academia -- stay tuned!</em></p>
<p><em>Big thanks to <a href="https://twitter.com/Ryan_A_Gillie">@Ryan_A_Gillie</a> for proofreading (and emotional support)</em></p>
<h1 id="the-generic-groundwork">The Generic Groundwork</h1>
<p>Generics are a powerful language tool to use in any language. In Rust, these are especially powerful, and by powerful I mean really efficient.</p>
<p>Let's look at a brief example to get familiar with syntax:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">trait </span><span style="color:#569fba;">HasPrintData </span><span style="color:#aeafb0;">{ </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="font-style:italic;color:#526176;">// Defines a generic T that must implement the `HasPrintData` trait
</span><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">cool_print</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> HasPrintData</span><span style="color:#aeafb0;">&gt;(</span><span style="color:#63cdcf;">data</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> T</span><span style="color:#aeafb0;">) { </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">struct </span><span style="color:#569fba;">MyType </span><span style="color:#aeafb0;">{ </span><span style="color:#d6d6d7;">data</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">&amp;</span><span style="font-style:italic;color:#9d79d6;">&#39;static </span><span style="color:#9d79d6;">str </span><span style="color:#aeafb0;">}
</span><span style="color:#9d79d6;">impl </span><span style="color:#63cdcf;">HasPrintData </span><span style="color:#ff9d00;">for </span><span style="color:#569fba;">MyType </span><span style="color:#aeafb0;">{ </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">let</span><span> asdf_data </span><span style="color:#d6d6d7;">=</span><span> MyType</span><span style="color:#aeafb0;">{</span><span style="color:#63cdcf;"> data</span><span style="color:#aeafb0;">: </span><span style="color:#81b29a;">&quot;</span><span style="color:#a3be8c;">asdf</span><span style="color:#81b29a;">&quot; </span><span style="color:#aeafb0;">};
</span><span style="color:#63cdcf;">cool_print</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">MyType</span><span style="color:#aeafb0;">&gt;(</span><span style="color:#63cdcf;">asdf_data</span><span style="color:#aeafb0;">);
</span></code></pre>
<p>As a Rustacean will proudly let you know, the efficiency comes from the fact that generics in Rust are zero-cost abstractions. <code>rustc</code> performs a process called <a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics">monomorphization</a>, where generic items (methods, structs, etc.) are &quot;flattened&quot; at compile time into only the types that are used. (Compare this to a language <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generics-in-the-run-time">like C#</a>, where generics are evaluated at runtime.)</p>
<p>An example:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#526176;">// We use `cool_print` with a parameter of type `MyType`
</span><span style="color:#9d79d6;">let</span><span> asdf_data</span><span style="color:#aeafb0;">:</span><span> MyType</span><span style="color:#aeafb0;">{</span><span style="color:#63cdcf;"> data</span><span style="color:#aeafb0;">: </span><span style="color:#81b29a;">&quot;</span><span style="color:#a3be8c;">asdf</span><span style="color:#81b29a;">&quot; </span><span style="color:#aeafb0;">};
</span><span style="color:#63cdcf;">cool_print</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">MyType</span><span style="color:#aeafb0;">&gt;(</span><span style="color:#63cdcf;">asdf_data</span><span style="color:#aeafb0;">)
</span><span>
</span><span style="font-style:italic;color:#526176;">// So, the function definition is transformed accordingly:
</span><span style="font-style:italic;color:#526176;">// fn cool_print&lt;T: HasPrintData&gt;(data: T) { /* ... */ } [no longer exists]
</span><span>   </span><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">cool_print_mytype</span><span style="color:#aeafb0;">(</span><span style="color:#63cdcf;">data</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> MyType</span><span style="color:#aeafb0;">) { </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="font-style:italic;color:#526176;">// This occurs for as many variations of `T` that exist in calls to `cool_print`.
</span><span style="font-style:italic;color:#526176;">// If we had `TypeA` and `TypeB`, which were both `HasPrintData`, also call `cool_print`,
</span><span style="font-style:italic;color:#526176;">// we&#39;d end up with the following additional definitions generated by the compiler:
</span><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">cool_print_typea</span><span style="color:#aeafb0;">(</span><span style="color:#63cdcf;">data</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> TypeA</span><span style="color:#aeafb0;">) { </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">cool_print_typeb</span><span style="color:#aeafb0;">(</span><span style="color:#63cdcf;">data</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> TypeB</span><span style="color:#aeafb0;">) { </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span></code></pre>
<blockquote>
<p>And of course, this leads to any further optimizations the compiler may decide to do, re: <a href="https://matklad.github.io/2021/07/09/inline-in-rust.html">inlining</a>.</p>
</blockquote>
<p>This is great! We have a mechanism that allows us to mix the convenience of generic programming with the speed of literally not doing it. However, as we are soon to see, there are more features that we would like generics to have.</p>
<h1 id="the-generic-problem">The Generic Problem</h1>
<p>There are a few limitations with plain-old generics. Compile time generics with monomorphization are great and all, but there's a specific pattern in the Rust language that would be nice to implement, well, generically: arrays!</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">let</span><span> my_nums </span><span style="color:#d6d6d7;">= </span><span style="color:#aeafb0;">[</span><span style="color:#f4a261;">0</span><span style="color:#aeafb0;">; </span><span style="color:#f4a261;">16</span><span style="color:#aeafb0;">]; </span><span style="font-style:italic;color:#526176;">// An array of 16 zeros
</span></code></pre>
<p>We just want an implementation (with magic syntax we won't get into<sup class="footnote-reference"><a href="#1">1</a></sup>) that goes something like this:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">make_arr</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt;() -&gt; </span><span style="font-style:italic;color:#526176;">/* something */ </span><span style="color:#aeafb0;">{ </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span></code></pre>
<p>But what <em>is</em> an array?</p>
<p>The existence of any array is inexorably linked to its capacity. Since Rust has a very developed type system, we can attach this idea (that an array capacity is part of the type) <em>directly to the type of the current instance of the array</em>... right?</p>
<p>Before we answer that, let's see how early Rust implemented arrays (<a href="https://github.com/rust-lang/rust/commit/9d39758d14df45956b1a8d8132e3e40c3558dd4b">src</a>):</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c94f6d;">macro_rules! </span><span style="color:#569fba;">array_impls </span><span style="color:#aeafb0;">{
</span><span style="color:#63cdcf;">    </span><span style="color:#aeafb0;">(</span><span style="color:#9d79d6;">$</span><span style="color:#aeafb0;">(</span><span style="color:#63cdcf;">$N</span><span style="color:#aeafb0;">:</span><span style="color:#9d79d6;">expr</span><span style="color:#aeafb0;">)</span><span style="color:#9d79d6;">+</span><span style="color:#aeafb0;">) </span><span style="color:#9d79d6;">=&gt; </span><span style="color:#aeafb0;">{
</span><span style="color:#63cdcf;">        </span><span style="color:#9d79d6;">$</span><span style="color:#aeafb0;">(
</span><span style="color:#63cdcf;">            </span><span style="color:#aeafb0;">#[</span><span style="color:#d6d6d7;">stable</span><span style="color:#aeafb0;">(</span><span style="color:#63cdcf;">feature </span><span style="color:#9d79d6;">= </span><span style="color:#81b29a;">&quot;</span><span style="color:#a3be8c;">rust1</span><span style="color:#81b29a;">&quot;</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> since </span><span style="color:#9d79d6;">= </span><span style="color:#81b29a;">&quot;</span><span style="color:#a3be8c;">1.0.0</span><span style="color:#81b29a;">&quot;</span><span style="color:#aeafb0;">)]
</span><span style="color:#63cdcf;">            </span><span style="color:#9d79d6;">impl</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt; </span><span style="color:#719cd6;">AsRef</span><span style="color:#aeafb0;">&lt;[</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">]&gt; </span><span style="color:#ff9d00;">for</span><span style="color:#63cdcf;"> [</span><span style="color:#569fba;">T</span><span style="color:#63cdcf;">; </span><span style="color:#d6d6d7;">$N</span><span style="color:#63cdcf;">] </span><span style="color:#aeafb0;">{ </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span style="color:#63cdcf;">        </span><span style="color:#aeafb0;">)
</span><span style="color:#63cdcf;">        </span><span style="font-style:italic;color:#526176;">// ...
</span><span style="color:#63cdcf;">    </span><span style="color:#aeafb0;">}</span><span style="color:#63cdcf;">))
</span><span style="color:#aeafb0;">}
</span><span style="font-style:italic;color:#526176;">//...
</span><span style="color:#719cd6;">array_impls! </span><span style="color:#aeafb0;">{
</span><span style="color:#63cdcf;">     </span><span style="color:#f4a261;">0  1  2  3  4  5  6  7  8  9
</span><span style="color:#63cdcf;">    </span><span style="color:#f4a261;">10 11 12 13 14 15 16 17 18 19
</span><span style="color:#63cdcf;">    </span><span style="color:#f4a261;">20 21 22 23 24 25 26 27 28 29
</span><span style="color:#63cdcf;">    </span><span style="color:#f4a261;">30 31 32
</span><span style="color:#aeafb0;">}
</span></code></pre>
<blockquote>
<p>And before that, in the <a href="https://github.com/rust-lang/rust/blob/33ef78fa8bbe9b8d05ba0da607d4da5e31475a95/src/libcore/array.rs">pre-alpha days of Rust</a>, arrays were defined with a variadic macro. The <code>/* something */</code> above was a <code>[T, ..$N]</code>, where <code>T</code> is the type, and <code>..$N</code> defines a range (I believe -- old Rust is weird) up to the number of specified elements.</p>
</blockquote>
<p>Ouch.</p>
<p>The standard library generates a new type for each <code>0..=N</code> for type <code>T</code> (e.g., <code>[T; 0], [T; 1], [T; 2]</code>).</p>
<p>This means that if we want to implement anything on top of array -- <code>Ord</code>, <code>PartialEq</code>, etc. -- that means we need to implement it for <em>all</em> types of the array. (And indeed, in old versions of Rust, <a href="https://doc.rust-lang.org/1.20.0/std/primitive.array.html">array docs</a> were really messy, as they showed each implementation for all <code>N</code>!)</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#526176;">// This * 7 or 8 traits * 32 total variations...
</span><span style="color:#9d79d6;">impl</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt;</span><span style="color:#63cdcf;"> Debug </span><span style="color:#ff9d00;">for</span><span style="color:#63cdcf;"> [</span><span style="color:#569fba;">T</span><span style="color:#63cdcf;">; 0]
</span><span style="color:#569fba;">impl</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt; </span><span style="color:#569fba;">Debug for</span><span style="color:#63cdcf;"> [</span><span style="color:#569fba;">T</span><span style="color:#63cdcf;">; 1]
</span><span style="color:#569fba;">impl</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt; </span><span style="color:#569fba;">Debug for</span><span style="color:#63cdcf;"> [</span><span style="color:#569fba;">T</span><span style="color:#63cdcf;">; 2]
</span><span style="color:#569fba;">impl</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt; </span><span style="color:#569fba;">Debug for</span><span style="color:#63cdcf;"> [</span><span style="color:#569fba;">T</span><span style="color:#63cdcf;">; 3]
</span><span style="color:#569fba;">impl</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T</span><span style="color:#aeafb0;">&gt; </span><span style="color:#569fba;">Debug for</span><span style="color:#63cdcf;"> [</span><span style="color:#569fba;">T</span><span style="color:#63cdcf;">; 4]
</span><span style="font-style:italic;color:#526176;">// ...
</span></code></pre>
<p>This problem is the perfect candidate for a new type of generic: <strong>const generics</strong>.</p>
<h1 id="the-o-1-generic-solution">The O(1) Generic Solution</h1>
<p>Const generics are presented very eloquently in <a href="https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md">RFC 2000: Const Generics</a>. I'm going to summarize that RFC later on, with some tangents where appropriate, but let's start with a brief overview of the topic.</p>
<p>On its own, a const generic is generic that is restricted to be a specific constant value, specified (simply) with the <code>const</code> keyword<sup class="footnote-reference"><a href="#2">2</a></sup>. I think they're best understood in the context of monomorphization.</p>
<p>Consider the following type:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">enum </span><span style="color:#569fba;">NoteName </span><span style="color:#aeafb0;">{</span><span style="color:#63cdcf;"> A</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> B</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> C</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> D</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> E</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> F</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> G </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">struct </span><span style="color:#569fba;">Note</span><span style="color:#aeafb0;">&lt;</span><span style="font-style:italic;color:#9d79d6;">const</span><span style="color:#63cdcf;"> P</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">i8</span><span style="color:#aeafb0;">&gt; {
</span><span style="color:#63cdcf;">    </span><span style="color:#d6d6d7;">name</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> NoteName
</span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">let</span><span> middle_c </span><span style="color:#d6d6d7;">= </span><span style="color:#63cdcf;">Note</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">3</span><span style="color:#aeafb0;">&gt;{</span><span style="color:#63cdcf;"> name</span><span style="color:#aeafb0;">: </span><span style="color:#63cdcf;">NoteName</span><span style="color:#aeafb0;">::</span><span style="color:#63cdcf;">C </span><span style="color:#aeafb0;">};
</span><span style="color:#9d79d6;">let</span><span> high_c   </span><span style="color:#d6d6d7;">= </span><span style="color:#63cdcf;">Note</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">4</span><span style="color:#aeafb0;">&gt;{</span><span style="color:#63cdcf;"> name</span><span style="color:#aeafb0;">: </span><span style="color:#63cdcf;">NoteName</span><span style="color:#aeafb0;">::</span><span style="color:#63cdcf;">C </span><span style="color:#aeafb0;">};
</span><span>
</span><span style="font-style:italic;color:#526176;">// Monomorphization will transform the above `Note` type into the following two types:
</span><span style="color:#9d79d6;">struct </span><span style="color:#569fba;">Note_3 </span><span style="color:#aeafb0;">{
</span><span style="color:#63cdcf;">    </span><span style="color:#d6d6d7;">name</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> NoteName
</span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">struct </span><span style="color:#569fba;">Note_4 </span><span style="color:#aeafb0;">{
</span><span style="color:#63cdcf;">    </span><span style="color:#d6d6d7;">name</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> NoteName
</span><span style="color:#aeafb0;">}
</span></code></pre>
<p>The important thing here is that <code>Note_3</code> and <code>Note_4</code> are their own <em>distinct type</em>. Consider the counterexample, if we had just used a new parameter in the field:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">enum </span><span style="color:#569fba;">NoteName </span><span style="color:#aeafb0;">{</span><span style="color:#63cdcf;"> A</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> B</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> C</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> D</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> E</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> F</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> G </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">struct </span><span style="color:#569fba;">Note </span><span style="color:#aeafb0;">{
</span><span style="color:#63cdcf;">    </span><span style="color:#d6d6d7;">pitch</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">i8</span><span style="color:#63cdcf;">,
</span><span style="color:#63cdcf;">    </span><span style="color:#d6d6d7;">name</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> NoteName
</span><span style="color:#aeafb0;">}
</span><span>
</span><span style="color:#9d79d6;">let</span><span> middle_c </span><span style="color:#d6d6d7;">=</span><span> Note </span><span style="color:#aeafb0;">{</span><span style="color:#63cdcf;"> name</span><span style="color:#aeafb0;">: </span><span style="color:#63cdcf;">NoteName</span><span style="color:#aeafb0;">::</span><span style="color:#63cdcf;">C</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> pitch</span><span style="color:#aeafb0;">: </span><span style="color:#f4a261;">3 </span><span style="color:#aeafb0;">};
</span><span style="color:#9d79d6;">let</span><span> middle_d </span><span style="color:#d6d6d7;">=</span><span> Note </span><span style="color:#aeafb0;">{</span><span style="color:#63cdcf;"> name</span><span style="color:#aeafb0;">: </span><span style="color:#63cdcf;">NoteName</span><span style="color:#aeafb0;">::</span><span style="color:#63cdcf;">D</span><span style="color:#aeafb0;">,</span><span style="color:#63cdcf;"> pitch</span><span style="color:#aeafb0;">: </span><span style="color:#f4a261;">3</span><span style="color:#aeafb0;">}
</span><span>
</span><span style="font-style:italic;color:#526176;">// Monomorphization does not occur here, as there are no generics in use.
</span></code></pre>
<p>This reveals the motivation behind the humble const generic. If we want to have a type that is exclusively distinguished by a constant (some might say &quot;by association&quot; of a constant), then a const generic is a fantastic qualifier. (Arrays are a good example here.) Otherwise, if a type will have <em>many</em> invocations with different values, it may be better to stick to a traditional parameter-in-struct approach.</p>
<p>Now that we've established the basics of const generics, let's dig more into the edge cases we may encounter.</p>
<h1 id="the-o-1-generic-technical-asterisks">The O(1) Generic Technical Asterisks</h1>
<p>One of the more important distinctions in <a href="https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md">the RFC</a> is between a <code>const</code> and a <em>const parameter</em>. A <code>const</code> is just a value that is guaranteed-known at compile time. A <em>const parameter</em> is a constant value that is then &quot;attached&quot; to an instance of a type or function.</p>
<p>(So, when we say we have a &quot;const generic&quot;, the generic is acting as a const parameter -- a value, known at compile time, that we attach to a type via monomorphization.)</p>
<p>We've seen an example above, but in closer detail, they're fairly straightforward:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">cool_print</span><span style="color:#aeafb0;">&lt;</span><span style="font-style:italic;color:#9d79d6;">const</span><span style="color:#63cdcf;"> T</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">usize</span><span style="color:#aeafb0;">&gt;() { </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span><span>
</span><span style="font-style:italic;color:#526176;">// Generally:
</span><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">foo</span><span style="color:#aeafb0;">&lt;</span><span style="font-style:italic;color:#9d79d6;">const </span><span style="color:#d6d6d7;">$iden</span><span style="color:#aeafb0;">:</span><span style="color:#63cdcf;"> Type</span><span style="color:#aeafb0;">&gt;()
</span><span style="font-style:italic;color:#526176;">// where </span><span style="font-style:italic;color:#d6d6d7;">$iden</span><span style="font-style:italic;color:#526176;"> is the identifier, and `Type` is the type of the constant to be rendered.
</span></code></pre>
<p>Const generics can also kind-of sort-of be expressions when called:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#63cdcf;">cool_print</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">3</span><span style="color:#aeafb0;">&gt;();      </span><span style="font-style:italic;color:#526176;">// Valid!
</span><span style="color:#63cdcf;">cool_print</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#c94f6d;">{</span><span style="color:#f4a261;">2 </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span>}</span><span style="color:#9d79d6;">&gt;</span><span style="color:#aeafb0;">(); </span><span style="font-style:italic;color:#526176;">// Also valid
</span></code></pre>
<p>Raw expressions are not possible within a function, however.</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">arr_gen</span><span style="color:#aeafb0;">&lt;</span><span style="font-style:italic;color:#9d79d6;">const</span><span style="color:#63cdcf;"> N</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">usize</span><span style="color:#aeafb0;">&gt;() -&gt; [</span><span style="color:#9d79d6;">i32</span><span style="color:#aeafb0;">;</span><span style="color:#63cdcf;"> N</span><span style="color:#aeafb0;">] {
</span><span style="color:#63cdcf;">    </span><span style="color:#aeafb0;">[</span><span style="color:#f4a261;">3</span><span style="color:#aeafb0;">;</span><span style="color:#63cdcf;"> N </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span style="color:#aeafb0;">]
</span><span style="color:#63cdcf;">    </span><span style="font-style:italic;color:#526176;">//  ^ cannot perform const operation using `N`
</span><span style="color:#aeafb0;">}
</span><span style="color:#63cdcf;">arr_gen</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">4</span><span style="color:#aeafb0;">&gt;();
</span><span>
</span><span style="font-style:italic;color:#526176;">// Note that this applies to expressions of the const generic,
</span><span style="font-style:italic;color:#526176;">// not the &quot;use&quot; of a generic in its callsite.
</span><span style="font-style:italic;color:#526176;">// The following is valid:
</span><span style="color:#63cdcf;">arr_gen</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#c94f6d;">{</span><span style="color:#f4a261;">4 </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span>}</span><span style="color:#9d79d6;">&gt;</span><span style="color:#aeafb0;">();
</span><span style="font-style:italic;color:#526176;">// but the following is not:
</span><span style="color:#63cdcf;">arr_gen</span><span style="color:#aeafb0;">::&lt;</span><span style="color:#63cdcf;">4 </span><span style="color:#9d79d6;">+</span><span style="color:#63cdcf;"> 1</span><span style="color:#aeafb0;">&gt;();
</span></code></pre>
<p>So sure, we can't use const generics as expressions. This should be a relatively straightforward issue to fix, alongside some other conveniences for generics... right?</p>
<h1 id="generic-communication">Generic Communication</h1>
<p>Despite this seeming like a straightforward feature overall, const generics don't have an entry in the Rust book. They are &quot;stabilized&quot;, in the sense that the MVP is stable and safe to use. And it took <a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html">three years</a> for the RFC to go from <code>accepted</code> to <code>beta</code>.</p>
<p>In response to the hype (and against the technical difficulty), a <a href="https://rust-lang.github.io/project-const-generics/">project group</a> was formed for const generics that's focused on aligning the overall implementation. They've been working on a book for a while to describe and align all the features together. (The <a href="https://github.com/rust-lang/rust/labels/A-const-generics"><code>A-const-generics</code></a> tag on the Rust GitHub has 101 open issues at time of writing!)</p>
<h1 id="generic-o-1-compiler-issues">Generic O(1) Compiler Issues</h1>
<p>Before we discuss the bleeding edge of const generics, let's take a quick look at an implementation of a specific const generics feature to better understand the complexity around this issue.</p>
<p>One of the more anticipated issues is the use of const generics as an expression:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">foo</span><span style="color:#aeafb0;">&lt;</span><span style="font-style:italic;color:#9d79d6;">const</span><span style="color:#63cdcf;"> T</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">usize</span><span style="color:#aeafb0;">&gt;() -&gt; [</span><span style="color:#9d79d6;">i32</span><span style="color:#aeafb0;">;</span><span style="color:#63cdcf;"> T </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span style="color:#aeafb0;">] { </span><span style="font-style:italic;color:#526176;">/* ... */ </span><span style="color:#aeafb0;">}
</span></code></pre>
<p>This is not currently possible due to an ambiguity around <strong>well-formed</strong> types.</p>
<p>A type is defined to be <a href="https://github.com/rust-lang/rfcs/blob/master/text/1214-projections-lifetimes-and-wf.md#summary">well-formed</a> iff it respects its declared bounds. Once we have a well-formed type, the compiler can then perform type checking. But there is a <a href="https://hackmd.io/OZG_XiLFRs2Xmw5s39jRzA?view#Const-equality">problem</a>:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#526176;">//                                 (1)
</span><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">foo</span><span style="color:#aeafb0;">&lt;</span><span style="font-style:italic;color:#9d79d6;">const</span><span style="color:#63cdcf;"> N</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">usize</span><span style="color:#aeafb0;">&gt;() -&gt; [</span><span style="color:#9d79d6;">i32</span><span style="color:#aeafb0;">;</span><span style="color:#63cdcf;"> N </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span style="color:#aeafb0;">] {
</span><span style="color:#63cdcf;">    </span><span style="font-style:italic;color:#526176;">//   (2)
</span><span style="color:#63cdcf;">    </span><span style="color:#aeafb0;">[</span><span style="color:#f4a261;">0</span><span style="color:#aeafb0;">;</span><span style="color:#63cdcf;"> N </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span style="color:#aeafb0;">];
</span><span style="color:#aeafb0;">}
</span></code></pre>
<p>The expression at <code>(1)</code>, according to the compiler, is not seen as the same as the expression at <code>(2)</code>! Therefore, even if <code>N</code> is well-formed, and <code>N + 1</code> is well-formed (that is, we can verify the type of <code>N + 1</code>), it's meaningless as we cannot currently see that both of those well-formed types are the equivalent, as they are not equatable.</p>
<blockquote>
<p>Taking a brief dive into rust/compiler/, the unification is defined to always fail <a href="https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler/rustc_trait_selection/src/traits/const_evaluatable.rs#L612">(<code>rustc_trait_selection/src/traits/const_evaluatable.rs</code>)</a>, and that failure is corroborated by a type error in a trait resolver <a href="https://github.com/rust-lang/rust/blob/e3c43e64eceb00e13b1932229aa9b2d774e6af96/compiler/rustc_resolve/src/ident.rs#L1208">(<code>rustc_resolve/src/ident.rs</code>)</a>.
It looks like the compiler uses an (anonymous) projection, i.e., every time it sees a new <code>const generic parameter</code>, it generates a new value determined by its input (but which may potentially be unknown<a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html">0</a>). Unification is not possible between two anonymous projections. (Although, some work has been done to tighten up the <em>reverse</em> -- that is, evaluation of anonymous constants which depend on anonymous types: <a href="https://github.com/rust-lang/rust/pull/74595">#74595</a>. Additional discussion on <a href="https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60ConstEvaluatable.60.20generic.20functions/near/204554918">this Zulip thread</a>.)</p>
<p>I can't seem to piece it together with the unification restriction, but <a href="https://github.com/rust-lang/rust/pull/74113">PR #74113</a> mentioned a recursive type check issue with const arguments. The problem occurs when the type checker references its <code>TypeckTables</code> of the surrounding body, attempting to look up the <code>const_arg</code> type. However, the <code>const_arg</code> may be defined <em>in the same scope</em>, which will cause an infinite loop. The solution is to instead check the type of the parameter's <code>def_id</code> (a unique(?) index into the <a href="https://rustc-dev-guide.rust-lang.org/hir.html#the-hir">HIR</a>) instead. This seems logical, as by definition, a <code>const generic parameter</code> is still <code>const</code> -- the type of which may be an expression itself, but that expression should not change further into its use.</p>
</blockquote>
<p>With these discrepancies, we can hopefully see how expressions for const generic parameters are difficult:</p>
<ul>
<li>Unification for separate-use generics is not supported (i.e., declaration, return type, and use) due to anonymous projections,</li>
<li>Type checking is wonky with respect to const generic arguments<sup class="footnote-reference"><a href="#3">3</a></sup> (hopefully fixed :pray:),</li>
<li>Anonymous (generic) constants can't be evaluated with anonymous types due to weird edge cases</li>
</ul>
<p>All of this is to point out the technical difficulty in implementing <em>one</em> additional &quot;user-facing&quot; feature for const generics. There's many dependencies that need to be addressed in order for the feature to actually land -- never mind land in a stable context.</p>
<h1 id="generic-future">Generic Future</h1>
<p>What about the future of const generics? What's left for the quirky language feature that axed one more set of macros from the standard library?</p>
<p>Looking through the <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_feature/src/active.rs">current list of nightly features</a>, there's a few relevant ones for const generics, in particular:</p>
<ul>
<li><strong>adt_const_params (<a href="https://github.com/rust-lang/rust/issues/95174">#95174</a>)</strong></li>
<li><strong>generic_arg_infer (<a href="https://github.com/rust-lang/rust/issues/85077">#85077</a>)</strong></li>
<li><strong>generic_const_exprs (<a href="https://github.com/rust-lang/rust/issues/76560">#76560</a>) (supportive issue)</strong></li>
</ul>
<p>The last RFC, <code>generic_const_exprs</code> proposes a new inline <code>const { ... }</code> syntax that allows for blocks of code to be evaluated into a <code>const</code> value at compile time<sup class="footnote-reference"><a href="#5">4</a></sup>. The relevant piece here for const generics is that currently, array length expressions cannot refer to generic parameters:</p>
<pre data-lang="rust" style="background-color:#232136;color:#cdcecf;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#9d79d6;">fn </span><span style="color:#86abdc;">gen_arr</span><span style="color:#aeafb0;">&lt;</span><span style="color:#63cdcf;">T, </span><span style="font-style:italic;color:#9d79d6;">const</span><span style="color:#63cdcf;"> N</span><span style="color:#aeafb0;">: </span><span style="color:#9d79d6;">usize</span><span style="color:#aeafb0;">&gt;() {
</span><span style="color:#63cdcf;">    </span><span style="color:#9d79d6;">let</span><span style="color:#63cdcf;"> cool_arr </span><span style="color:#d6d6d7;">= </span><span style="color:#aeafb0;">[</span><span style="color:#f4a261;">4</span><span style="color:#9d79d6;">i32</span><span style="color:#aeafb0;">;</span><span style="color:#63cdcf;"> N </span><span style="color:#9d79d6;">+ </span><span style="color:#f4a261;">1</span><span style="color:#aeafb0;">];
</span><span style="color:#aeafb0;">}
</span></code></pre>
<p>(This might be useful in side-stepping the const generic expression limitations, or at the very least in making more of the code readable for contexts where arrays depend on the size of a type, i.e., <code>std::mem::size_of::&lt;T&gt;()</code>.)</p>
<p>Aside from these specific issues and proposals, there continues to be ongoing discussion in the way of documenting the immense technicality of const generics. This requires collaboration between many areas of the Rust project (compiler, lang, std library), and it can be difficult to coordinate what should be possible vs. what is possible to implement vs. what people have the time to dedicate to.</p>
<blockquote>
<p>The fact that the RFC was feature-flagged with <code>mvp_</code> should be enough indication that this is a big job!</p>
</blockquote>
<h1 id="a-generic-summary">A Generic Summary</h1>
<p>Overall, we've explored many things:</p>
<ul>
<li>Basic use of generics in Rust</li>
<li><code>const generics</code></li>
<li>Compiler optimizations (monomorphization, inlining)</li>
<li>Macro workarounds</li>
<li>The communication challenges of implementing a widely-scoped technical feature<sup class="footnote-reference"><a href="#4">5</a></sup></li>
<li>A brief look into the compiler's implementation (and restriction around) const generic expressions</li>
<li>Future proposals for const generics</li>
</ul>
<p>This goes to show the impressive complexity and power underneath every Rust feature. I personally am looking forward to see new updates from the const generics working group!</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The <a href="https://github.com/rust-lang/rfcs/blob/master/text/0520-new-array-repeat-syntax.md">RFC 0520</a> added the magic syntax. It's 2014 Rust, so good luck!</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>What's nice is that the const generics group has <a href="https://rust-lang.github.io/project-const-generics/vision/why-compile-time-evaluation.html#consistent-just-add-const">stated</a> that being able to &quot;just add const&quot; is a key goal of the project. I think this is a great way to keep down unnecessary complexity, which the problem of &quot;complexity vs. sugar&quot; is a <a href="https://www.hackingwithswift.com/interviews/chris-lattner-will-swift-evolution-ever-slow-down">hotly debated topic</a> in many languages, re: if we can reuse existing intuitive syntax, we might as well, instead of creating new fancy syntax just for this feature.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>See the const generic <a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html">RFC 2000</a> for a technical definition of <code>const generic parameter</code> vs. <code>const generic argument</code></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">5</sup>
<p>Scoped in technical nature, not in initial featureset. The RFC is remarkably concise!</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">4</sup>
<p>Future Peter here: I wrote this section quite late in the night, and this part might be a bit wrong. I can't find the idea I talked about in the GH issue itself, but it feels right. Reach out to me on Twitter <a href="https://twitter.com/pkos91">@pkos91</a> if you want to correct me!</p>
</div>

        </section>

        

    </article>
</main>


    </div>
</body>

</html>