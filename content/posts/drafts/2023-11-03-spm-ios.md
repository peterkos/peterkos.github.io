+++
title = "Swift Package Manager + iOS"
date = 2023-11-03
draft = true
+++

## Background

This all started because Xcode was too slow.

Each launch of an SPM project would lead Xcode to "Resolve packages...", even if no dependencies changed. There wasn't an outward fix, with various [poking-and-prodding](https://forums.developer.apple.com/forums/thread/678974), "raise your right hand and click compile" solutions yielding no results. Alas, we were doomed to wait 1-2 minutes each time Xcode started.

_"But Peter, why not use ~~vim~~ [helix](https://helix-editor.com/)?"_ 

Oh, we'll get there.

_"But Peter, why were you restarting Xcode so much?"_

We were using xcodegen, which requires [re-running](https://github.com/yonaskolb/XcodeGen/blob/master/Docs/FAQ.md#what-happens-when-i-switch-branches) if files were added/removed, which is likely when switching branches. This generates a new `.xcodeproj` file, which Xcode is actively using... so, a restart is necessary. Tack on some code reviews, testing feedback, your own feature branch, and the-one-branch-someone-needed-help-with, and you'll end up with the following:

```fish
# ~/.config/fish/config.fish
alias kx "killall Xcode"
```

**Problem: Xcode is too slow.**
What are our options?
- Switch to Android
- Use another editor
- Be patient

Patience is a virtue held until one realizes their processor runs _four billion cycles a second_, which is $4.8Ã—10^{11}$ cycles as you stare at Xcode. Android might take a while to learn, so let's try out a new editor for the time being.

## The Language Server Protocol to My Heart

Luckily, the folks at Redmond built [LSP](https://microsoft.github.io/language-server-protocol/). Any editor can hook into some language's backend for autocomplete+formatting, and all it needs to worry about is how to show that information to the user.


## We Need To Go Deeper (SPM)

those PRs are almost right...


## Found it!

_AHHH!!!_

Let's look at a standalone project to demonstrate the issue.

1. Create a project with `swift package new testproj`
1. Add a dependency (i.e., Factory) to `Package.swift` that has both iOS _and_ macOS targets:


```swift,hl_lines=5 12-14 18
// swift-tools-version: 5.9
import PackageDescription
let package = Package(
    name: "testproj",
    platforms: [.iOS(.v16)],
    products: [
        .library(
            name: "testproj",
            targets: ["testproj"]
        ),
    ],
    dependencies: [
        .package(url: "https://github.com/hmlongco/Factory", from: "2.3.1")
    ],
    targets: [
        .target(
            name: "testproj",
            dependencies: ["Factory"]
        ),
        .testTarget(
            name: "testprojTests",
            dependencies: ["testproj"]
        ),
    ]
)
```

If one were to FOOLISHLY run this PREPOSTEROUS configuration on macOS 10.13, the following is observed:

```sh
> swift build --triple arm64-apple-ios-simulator \
              --sdk "$(xcrun --sdk iphonesimulator --show-sdk-path)"

error: the library 'testproj' requires macos 10.13,
       but depends on the product 'Factory' which requires macos 10.14;
       consider changing the library 'testproj' to require macos 10.14 or later,
       or the product 'Factory' to require macos 10.13 or earlier.
```

It's checking `macOS` versions, even though we only specified `.iOS(.v16)` as a platform. Turns out, there's this cute snippet in the [SPM docs](https://github.com/apple/swift-package-manager/blob/main/Documentation/PackageDescription.md#supportedplatform):


<div class="note">
    <p><i class="fa-solid fa-angles-right"></i>By default, the Swift Package Manager assigns a predefined minimum deployment version for each supported platforms [sic] unless you configure supported platforms [sic] using the platforms API.</p>
</div>

That means our Package.swift actually looks like _this_:

```swift, hl_lines=3
platforms: [
    .iOS(.v16),
    .macOS(.v13)
],

// Factory's Package.swift
// src: https://github.com/hmlongco/Factory/blob/main/Package.swift
platforms: [
    .iOS(.v11),
    .macOS(.v10_14),
    .tvOS(.v13),
    .watchOS(.v8)
],
```

Our dependency has a higher minimum for `macOS` than our project does. Sure, it's quirky that SPM infers defaults like that, but think back to our original command. We didn't _specify_ macOS. We specified _iOS_!

```sh
> swift build --triple arm64-apple-ios-simulator \
              --sdk "$(xcrun --sdk iphonesimulator --show-sdk-path)"
```

<div class="note">
    <p><i class="fa-solid fa-lightbulb"></i> SPM isn't respecting the platform inferred from `--triple` by the time we validate our dependencies.</p>
</div>

Putting our thinking hats on, what could go wrong?
- Flattening iOS/macOS down to darwin while parsing args, and if `platform == darwin`, treating that as macOS
- Assuming the


at different points:
- Passing args to the compiler's build flags
