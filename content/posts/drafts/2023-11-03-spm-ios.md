+++
title = "Swift Package Manager + iOS"
date = 2023-11-03
draft = true
+++

# Swift Package Manager + iOS


## Background


## Debugging: LSP


## We Need To Go Deeper (SPM)

those PRs are almost right...


## Found it!

_AHHH!!!_

Let's look at a standalone project to demonstrate the issue.

1. Create a project with `swift package new testproj`
1. Add a dependency (i.e., Factory) to `Package.swift` that has both iOS _and_ macOS targets:


```swift,hl_lines=5 12-14 18
// swift-tools-version: 5.9
import PackageDescription
let package = Package(
    name: "testproj",
    platforms: [.iOS(.v16)],
    products: [
        .library(
            name: "testproj",
            targets: ["testproj"]
        ),
    ],
    dependencies: [
        .package(url: "https://github.com/hmlongco/Factory", from: "2.3.1")
    ],
    targets: [
        .target(
            name: "testproj",
            dependencies: ["Factory"]
        ),
        .testTarget(
            name: "testprojTests",
            dependencies: ["testproj"]
        ),
    ]
)
```

If one were to FOOLISHLY run this PREPOSTEROUS configuration on macOS 10.13, the following is observed:

```sh
> swift build --triple arm64-apple-ios-simulator \
              --sdk "$(xcrun --sdk iphonesimulator --show-sdk-path)"

error: the library 'testproj' requires macos 10.13,
       but depends on the product 'Factory' which requires macos 10.14;
       consider changing the library 'testproj' to require macos 10.14 or later,
       or the product 'Factory' to require macos 10.13 or earlier.
```

It's checking `macOS` versions, even though we only specified `.iOS(.v16)` as a platform. Turns out, there's this cute snippet in the [SPM docs](https://github.com/apple/swift-package-manager/blob/main/Documentation/PackageDescription.md#supportedplatform):


<div class="note">
    <p><i class="fa-solid fa-angles-right"></i>By default, the Swift Package Manager assigns a predefined minimum deployment version for each supported platforms [sic] unless you configure supported platforms [sic] using the platforms API.</p>
</div>

That means our Package.swift actually looks like _this_:

```swift, hl_lines=3
platforms: [
    .iOS(.v16),
    .macOS(.v13)
],
dependencies: [
    .package(url: "https://github.com/hmlongco/Factory", from: "2.3.1")
],
```

Compare this to Factory's [Package.swift](https://github.com/hmlongco/Factory/blob/main/Package.swift):

```swift, hl_lines=3
platforms: [
    .iOS(.v11),
    .macOS(.v10_14),
    .tvOS(.v13),
    .watchOS(.v8)
],
```

Our dependency has a higher minimum for `macOS` than our project does. Sure, it's quirky that SPM infers defaults like that, but think back to our original command. We didn't _specify_ macOS. We specified _iOS_!

```sh
> swift build --triple arm64-apple-ios-simulator \
              --sdk "$(xcrun --sdk iphonesimulator --show-sdk-path)"
```

<div class="note">
    <p><i class="fa-solid fa-lightbulb"></i> SPM isn't respecting the platform inferred from `--triple` by the time we validate our dependencies.</p>
</div>

Putting our thinking hats on, what could go wrong?
- Flattening iOS/macOS down to darwin while parsing args, and if `platform == darwin`, treating that as macOS
- Assuming the


at different points:
- Passing args to the compiler's build flags
