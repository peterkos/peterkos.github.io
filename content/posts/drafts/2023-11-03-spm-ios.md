+++
title = "Fixing Swift Package Manager to Compile for iOS"
date = 2023-11-03
draft = true
+++

# Background

This all started because Xcode was too slow.

Every time I opened Xcode, _every time_, it would attempt to resolve packages. Even if no dependencies changed. There was no obvious fix, with various [poke-and-prod](https://forums.developer.apple.com/forums/thread/678974), "raise your right hand and click compile" solutions yielding no results. Alas, we were doomed to wait 1-2 minutes each time Xcode started.

> "But Peter, why not use another editor? Like ~~vim~~ [helix](https://helix-editor.com/)?"

Oh we'll get there.

> "But Peter, why were you restarting Xcode so much?"

We had a large number of engineers, so it made sense to use `xcodegen` to generate our .xcodeproj file and cut down on the number of XML merge conflicts. However, if files were added/removed, we had to [re-run the generation]((https://github.com/yonaskolb/XcodeGen/blob/master/Docs/FAQ.md#what-happens-when-i-switch-branches)). Since the `.xcodeproj` file is actively read by Xcode while it's open, Xcode needed to be given a polite restart. No issue... except for the very high likelihood that files are added/removed on new branches. Tack on some code reviews, testing feedback, `branch-chris-final`, your own feature branch, and the-one-branch-someone-needed-help-with, and you'll end up with the following:

```fish
# ~/.config/fish/config.fish
alias kx "killall Xcode"
```

So... Xcode is too slow. What are our options?
- Be patient
- Switch to Android
- Use another editor

Patience is a virtue held until one realizes their processor runs _four billion cycles a second_, which is $4.8Ã—10^{11}$ cycles as you stare at Xcode. Android is green, and I'm colorblind. New editor it is.

> **ðŸš§ï¸ Disclaimer**
>
> I did this around a year ago, circa Swift 5.9. Any code referenced below is pulled from branches around that time (e.g., `sourcekit-lsp/release/5.9`).
>
> For those inclined to replicate this, uh, experiment, it requires a couple preparation steps:
> 1. Use macOS Sonoma (14), and if you need a VM, [Bushel](https://getbushel.app/) is a great tool
> 1. Either [install a custom Swift toolchain](https://www.swift.org/install/macos/package_installer/), or (since we're in a VM), use [`xcodes`](https://github.com/XcodesOrg/xcodes) and install Xcode 15.4, which we can [verify](https://xcodereleases.com/) uses Swift 5.9
> 1. Finally, if following along, use the setup steps _on the 5.9 branch of each project_. The instructions have changed!

# The Language Server Protocol to My Heart

Luckily, the folks at Redmond put down their photocopiers and built [LSP](https://microsoft.github.io/language-server-protocol/). Any editor can hook into some language's backend for autocomplete+formatting, and all it needs to worry about is how to show that information to the user. [SourceKit-LSP](https://github.com/apple/sourcekit-lsp/) enables it to work with Swift! This is a good start.

I've been playing around with [helix](https://helix-editor.com), so let's fire up a new iOS project in Xcode for Swift/SwiftUI, open it in Helix, aaaand...

```sh
[ERROR] sourcekit-lsp err
        "could not find manifest, or not a SwiftPM package: [...]SwiftFlashlight\n"
[ERROR] sourcekit-lsp err
        "could not open compilation database for
        [...]SwiftDemo/SwiftFlashlight/ContentView.swift\n"
[ERROR] editor error: no such command: 'log-o'
```

Oops. Since sourcekit-lsp [doesn't yet support Xcode projects](https://github.com/apple/sourcekit-lsp/issues/730), we need to create this app as a **Swift Package Manager** (SPM) package.

```sh
> mkdir SwiftFlashlightCore
> cd SwiftFlashlightCore
> swift package init --name "SwiftFlashlightCore"
> ls
Package.swift Sources Tests
> hx .
```

And with some scaffolding...
```swift
// Package.swift
let package = Package(
    name: "SwiftFlashlightCore",
    platforms: [.iOS(.v16)],
    // ...
)

// Sources/SwiftFlashlightCore/SwiftFlashlightCore.swift
public func sayHello() {
    print("Hello, World!")
}
```

Woo! We have autocomplete!

<img src="/post-assets/spm-ios/helix-spm-v1.png" class="half-center" alt="screenshot of helix editor with autocomplete in package.swift file on the .library function"/>

We still need Xcode to do code signing, distribution, and not alienate the entire dev team. To solve this, we can make a wrapper Xcode project that imports this SPM package locally. The best part? This lets us modularize our code! Network module, UI module, that sort of thing, with each being a separate SPM package. That'll give us an excuse to continue earing gold medals in editor gymnastics.

To add a local SPM package dependency to an Xcode project:
1. Xcode -> New Project... -> iOS App
1. File -> "Add Package Dependencies"
1. "Add Local...", and navigate to SwiftFlashlightCore from the last step
1. Make sure "SwiftFlashlight" target is selected under "Add To Target"

Now, we can call our package's test function from within Xcode:

```swift
// SwiftFlashlight/ContentView.swift
import SwiftUI
import SwiftFlashlightCore

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
            .onAppear {
                SwiftFlashlightCore.sayHello()
            }
    }
}
```

# We Need To Go Deeper

Things fell apart when I tried loading the full iOS codebase, dependencies and all. SPM failed to initialize, and the LSP logs were not very helpful. I switched to the more familiar Sublime Text (sorry helix), and started digging.

The bug didn't appear on all modules of our codebase, or in a standalone `swift package init` project. It was only when we included some dependencies. Entertaining a brief _deus ex machina_, let's coincidentally pick one such dependency used from the full project:

```swift,hl_lines=5 12-14 18
// swift-tools-version: 5.9
import PackageDescription
let package = Package(
    name: "ProblemApp",
    platforms: [.iOS(.v16)],
    products: [
        .library(
            name: "ProblemApp",
            targets: ["ProblemApp"]
        ),
    ],
    dependencies: [
        .package(url: "https://github.com/hmlongco/Factory", from: "2.3.1")
    ],
    targets: [
        .target(
            name: "ProblemApp",
            dependencies: ["Factory"]
        ),
        .testTarget(
            name: "ProblemAppTests",
            dependencies: ["ProblemApp"]
        ),
    ]
)
```

If I tried to create this isolated test case _earlier_ in my journey (instead of debugging the full module I saw the errors occur in), I would have discovered something interesting.

```json
// LSP log
[error]: a resolved file is required when automatic dependency resolution is disabled
         and should be placed at [...]/ProblemApp/Package.resolved.
         Running resolver because the following dependencies were added: 'factory'
         (https://github.com/hmlongco/Factory)
```

Following its direction and running `swift build` (to resolve our dependencies) reveals the stone in the sword:

```sh
> swift build
# ...
Working copy of https://github.com/hmlongco/Factory resolved at 2.4.3
error: the library 'ProblemApp' requires macos 10.13, but depends on the product 'Factory' which
requires macos 10.14; consider changing the library 'ProblemApp' to require macos 10.14 or later,
or the product 'Factory' to require macos 10.13 or earlier.
```

The dependency resolution error occurred in `swift build`. Since I **didn't** make that observation at the time, we're going to proceed as past-me did: only aware that this error surfaced in the LSP, and not identically in both the LSP and build system. Granted, I would have needed to get lucky with that _specific_ dependency (more on that later), so it's not the end of the world.

```swift
// LSP logs
error: the library 'ProblemAppp' requires macos 10.13,
but depends on the product 'hmlongco/Factory' which requires macos 10.14;  [...]
```

We're seeing a macOS build error, but we specified **iOS** as our platform in the Package.swift. This led to some questions:
1. Where does SourceKit-LSP infer target architecture?
1. Is the LSP rebuilding our package, or is the error in the build system?
1. Why was our iOS platform setting ignored?

# Setup the Debug Environment

My first instinct was to clone SourceKit-LSP and set breakpoints. Surely the problem would reveal itself somewhere down the chain. I did so using Sublime Text. (A stubborn mistake.)

I set Sublime's SourceKit LSP to point to our local clone, not the one on the system toolchain:

```sh
> gh repo clone swiftlang/sourcekit-lsp
> cd sourcekit-lsp
# Need a build first so we can run something
> swift build
> cd .build/arm64-apple-macosx/debug
# Copy the current directory's path to the clipboard
> pwd | pbcopy
```
```json
// LSP-SourceKit.sublime-settings
{
  "enabled": true,
  "command": [
    "[...]/sourcekit-lsp/.build/arm64-apple-macosx/debug/sourcekit-lsp"
  ],
}
```

<details>
    <summary><i>A brief tangent on wrangling LLDB into Sublime Text</i></summary>

To set breakpoints via LLDB, I found [SublimeDebugger](https://github.com/daveleroy/SublimeDebugger), created a Sublime Project around the directory, set a configuration... but it failed to catch on anything.

```json
// sourcekit-lsp.sublime-project
"debugger_configurations":[{
    "type": "lldb",
    "request": "attach",
    "name": "Attach",
    "program": "${folder}/.build/arm64-apple-macosx/debug/sourcekit-lsp",
    "waitFor": true,
    "lldb.library": "/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/LLDB",
    "lldb.verboseLogging": true
}]
```

After about a week (I wish I was kidding), the first culprit was found. This plugin was a wrapper of codelldb, whose [Swift setup docs](https://github.com/vadimcn/codelldb/wiki/Swift) mention to set `lldb.library` manually. But! SublimeDebugger has this [horrific](https://github.com/daveleroy/SublimeDebugger/blob/95b7098d6d432e38b847bd1d42c525186e4e64f8/Debugger.sublime-settings#L57-L58) line in its config, overriding any lldb.library setting to `null` implicitly. Solution: remove the `lldb_library` from the project config, and add it as a plugin config item instead, [file an issue](https://github.com/daveleroy/SublimeDebugger/issues/229), and mark another week of my life spent debugging configuration files.

```json
// Debugger.sublime-settings
{
    "lldb_library": "/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/LLDB",
}
```
</details>

# Where does SourceKit-LSP infer target architecture?

The error we're getting from our LSP log panel in Sublime is below:
```swift
[18:19:38.668] { message: "[info]: using 'Package.resolved' file as lock file" }
[18:19:38.668] { message: "[debug]: loading manifest for 'ProblemApp' v. unknown from db cache" }
[18:19:38.668] { message: "[debug]: loading manifest for 'factory' v. 2.4.3 from db cache" }
[18:19:38.668] {
  message: "[error]: the library 'ProblemAppCore' requires macos 10.13,
             but depends on the product 'Factory' which requires macos 10.14;
             consider changing the library 'ProblemApp' to require macos 10.14 or later,
             or the product 'Factory' to require macos 10.13 or earlier.",
  logName: 'SourceKit-LSP: Indexing'
}
```

A quick folder-wide search for substrings from the log[^1] reveals code from one of its dependencies, Swift Package Manager. I'm tempted to start debugging it from the SPM side of things, but I'm curious if SourceKit-LSP is passing some invalid assertion of state (e.g., an override to the build system's environment, based on what it can statically infer from the Package manifest).

[^1]: An indispensable debugging tool, if I may add.

First we need to verify that SPM is indeed being used. The documentation on the `release/5.9` branch [states](https://github.com/swiftlang/sourcekit-lsp/tree/release/5.9?tab=readme-ov-file#caveats):
> SourceKit-LSP does not update its global index in the background, but instead relies on indexing-while-building to provide data. This only affects global queries like find-references and jump-to-definition.
>   Workaround: build the project to update the index

Documentation is [usually](https://github.com/ra1028/DifferenceKit/issues/152) correct, but let's take a peek at the code to verify:

```swift,hl_lines=8
// Sources/SourceKitLSP/Workspace.swift
convenience public init(rootUri: DocumentURI, buildSetup: BuildSetup, /* ... */) throws {
    var buildSystem: BuildSystem? = nil
    // ...
    if let buildServer = BuildServerBuildSystem(/* ... */) {
        buildSystem = buildServer
    } else if let swiftpm = SwiftPMWorkspace(/* ... */) {
        buildSystem = swiftpm
    }
    // ...
}
```
```swift
// Sources/SKCore/BuildServerBuildSystem.swift

/// A `BuildSystem` based on communicating with a build server.
/// Provides build settings from a build server launched based on a
/// `buildServer.json` configuration file provided in the repo root.
public final class BuildServerBuildSystem { /* ... */ }
```

`BuildServerBuildSystem` is, helpfully, only used when specified -- and indeed, breakpoints validate that we're calling `SwiftPMWorkspace`.

"Wait!" exclaimed past-me.

(I waited.)

"What happens when I try to build this on the command line with SPM? Maybe SPM is parsing our Package manifest wrong? After all, we still need run a build first[^2] to generate a symbol dictionary, from which SourceKit-LSP can do lookups and completions. So let's ignore LSP for now!"

Good point, past-me. I'll allow it.

[^2]: Note: <a href="https://github.com/swiftlang/sourcekit-lsp/blob/main/Documentation/Enable%20Experimental%20Background%20Indexing.md">Starting in Swift 6.1</a>, SourceKit-LSP will have background indexing enabled by default.

# Where does SPM infer target architecture?

```sh
> swift build
error: the library 'testproj' requires macos 10.13,
       but depends on the product 'Factory' which requires macos 10.14; [...]
```

The build system is checking `macOS` versions, even though we only specified `.iOS(.v16)` as a platform! What?!

Turns out, there's this cute snippet in the [SPM docs](https://github.com/apple/swift-package-manager/blob/main/Documentation/PackageDescription.md#supportedplatform):

<div class="note">
    <p><i class="fa-solid fa-angles-right"></i>By default, the Swift Package Manager assigns a predefined minimum deployment version for each supported platforms [sic] unless you configure supported platforms using the platforms API. [...] One exception to this rule is macOS, for which the minimum deployment target version starts from 10.10.</p><br>
    <p>The Swift Package Manager will emit an error if a dependency is not compatible with the top-level package's deployment version. The deployment target of a package's dependencies must be lower than or equal to the top-level package's deployment target version for a particular platform.</p>
</div>

That means our Package.swift actually looks like _this_:

```swift, hl_lines=3
platforms: [
    .iOS(.v16),
    .macOS(.v10_13) // Implicitly added!
],
```

Remember when I said I'd get _quite_ lucky by picking Factory as our dependency of choice for the standalone package?

```swift, hl_lines=5
// Factory's Package.swift
// src: https://github.com/hmlongco/Factory/blob/main/Package.swift
platforms: [
    .iOS(.v11),
    .macOS(.v10_14),
    .tvOS(.v13),
    .watchOS(.v8)
],
```

Our dependency has a lower minimum for macOS (.v10_13) than our package supports (.v10_14)! Yes, yes, this is exactly what the error message said. But we're at a semantic impasse. While I could set something silly, like a `.macOS("v99")`, that would only solve the dependency resolution issue. This is an iOS package, and we only want it to be built for iOS. Maybe we can set this as a flag in SPM? How can we make SPM target iOS, not macOS?

## Get SPM to target iOS, not macOS

Before we wear out our `-` key in Terminal, let's clarify some jargon.

<table>
<tr>
    <td><code>architecture</code></td>
    <td>arm64, x86, etc.</td>
</tr>
<tr>
    <td><code>host</code></td>
    <td>The system that runs the compiler</td>
</tr>
<tr>
    <td><code>target</code></td>
    <td>The system we want to run our executable on</td>
</tr>
<tr>
    <td><code>toolchain</code>*</td>
    <td>The compiler and supporting cast (linker, standard library, etc.)</td>
</tr>
<tr>
    <td><code>triple</code></td>
    <td><a href="https://github.com/swiftlang/llvm-project/blob/6f784e44b2fa0e018d4c5f31823f0264b7c505f7/llvm/include/llvm/TargetParser/Triple.h#L23-L25" target="_blank">Shorthand</a> for <code>arch-vendor-operating_system-(environment)</code></td>
<tr>
    <td><code>sdk</code></td>
    <td>Code libraries for platform-specific development (UIKit, etc.)</td>
</tr>
</table>

<small>*See [these](https://samwize.com/2022/05/23/how-to-use-a-different-swift-toolchain-in-xcode/) [two](https://oleb.net/2024/swift-toolchains/) articles for how to configure a new Swift toolchain.</small>


Our goal is to compile our SPM package with an iOS target from our Mac. While both platforms use ARM, it technically counts as cross-compilation, as `arch(macOS) != arch(iOS)`, so the details (sdk, toolchain) can't be inferred from the surrounding environment, even if the instruction sets are the same.

How do we specify our target? With a `--target` flag, probably. But where? Is `swift build --target ...` enough? Luckily, I've stared at my terminal like it's paint drying for long enough that some of these words start to make sense.

| Command | Description |
|---|---|
| `xcodebuild` | Runs the Xcode build system via the command line |
| `xcrun` | Use the Xcode environment (Swift version, etc.) to proxy commands, or get info |
| `swift build` | Runs the SPM build tool that _invokes_ compiler(s) to build source files |
| `swiftc` | The Swift compiler |


After some `man swift`, `swift -h`, `swift --h`, `swift help -h`, `swift -h | grep help`:

```sh
> swift build \
  --sdk    /path/to/ios/sdk \
  -Xswiftc -target \
  -Xswiftc arm64-apple-ios16 \
  -Xcc     --target=arm64-apple-ios16 \
  -Xcxx    --target=arm64-apple-ios16 \
```

This command tells the Swift compiler and all C/C++ compilers down the chain to set our target to iOS 16. To find the iOS SDK path, we need to ask the all-seeing, all-knowing, omniscient Xcode.

```sh
> xcodebuild -showsdks
iOS SDKs:
	iOS 16.0                -sdk iphoneos16.0
iOS Simulator SDKs:
	Simulator - iOS 16.0    -sdk iphonesimulator16.0
```

```sh
> xcrun --sdk iphonesimulator16.0 --show-sdk-path
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk
```

> I decided to stick with the _simulator_ SDK, even though I couldn't think of a reason the simulator would need nor have a different SDK than a physical device.

Along the way, I also discovered [this neat PR](https://github.com/swiftlang/swift-package-manager/pull/6732) that lets use `--triple` for iOS targets. Let's use that instead, and add our SDK path to `swift build`:

```sh
> swift build \
  --triple arm64-apple-ios-simulator \
  --sdk "$(xcrun --sdk iphonesimulator --show-sdk-path)"
```

```swift
error: the library 'ProblemApp' requires macos 10.13,
but depends on the product 'hmlongco/Factory' which requires macos 10.14;  [...]
```

ARE YOU KIDDING ME.

I was frustrated. We set our platform in `Package.swift` to be iOS. We told SPM to compile for iOS. Why was it falling back to macOS?

<!-- > Later, we'll need to point SourceKit-LSP to use our local copy of SPM, but for now, we're only debugging the SPM <-> Swift compiler link. -->

# Uh oh, he's opening FigJam

I'd like to take you on a tour of the SPM codebase, focusing on three areas:
1. Configuring the build system
1. Starting the build system
1. Initial checks just before running the build system

My approach here is simple: trace the execution path from `swift build` down to where the error is being thrown.

## Configuring the build system

The main kickoff (post-CLI argument parsing) is a bit hard to follow at first. The reasoning is good -- to [optimize the toolchain install size](https://github.com/swiftlang/swift-package-manager/pull/3276) -- but I skipped this _entire_ path when originally debugging.
```swift
// Sources/swift-build/main.swift
SwiftBuildTool.main()

// Sources/Commands/SwiftBuildTool.swift
public struct SwiftBuildTool: SwiftCommand { /* ... */ }

// Sources/CoreCommands/SwiftCommandState.swift
public protocol SwiftCommand: ParsableCommand, _SwiftCommand { /* ... */ }

// .build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types
public static func main(_ arguments: [String]?) {
    // ...
    do {
        var command = try parseAsRoot(arguments)
        try command.run()
    } catch {
        exit(withError: error)
    }
}
```

That's a bunch of code to say `X.main()` calls `X.run()`, bringing us to `SwiftBuildTool.run()`:

```swift, hl_lines=3 8
public func run(_ swiftTool: SwiftTool) throws {
    // ...
    let buildSystem = try swiftTool.createBuildSystem(
        explicitProduct: options.product,
        customOutputStream: TSCBasic.stdoutStream
    )
    do {
        try buildSystem.build(subset: subset)
    } catch _ as Diagnostics {
        throw ExitCode.failure
    }
}
```

(We'll get to the build system code later.)

_At the time_, I didn't start there. It was only through writing this blog post that I discovered that code path. Originally, I started at `SwiftBootstrap`, which is a trimmed-down version of `swift-build` to build SPM itself[^3]. As we'll see in the diagrams below, we still hit those two key methods: `createBuildSystem(...)` and `build(...)`, so... I guess it doesn't matter?

[^3]: This is a common concept in compilers: the Swift compiler compiles itself, the Rust compiler compiles itself, and so on. Doesn't make it any less confusing :')

> "But Peter, why didn't you cut this out of the blog post? It doesn't matter! Show us the fix!!!11!11!"

I want this to be as historically-accurate of a debugging tale as possible. I was stressed, juggling an alphabet soup of new jargon, and spending _hours_ on things that should have been quick -- setting `$TOOLCHAIN` instead of `$TOOLCHAINS`, or working with the wrong Swift version. Build systems are complex beasts. They require the utmost attention to detail throughout each layer of the process. Sometimes I get lucky, as seen below, where an entirely different entry point that I _wasn't_ calling ended up taking me to the same build system code.

I thought -- **even after fixing the bug** -- that my mental model of the system was correct. It was not! The parts that mattered, insofar as calling `BuildOperation.build()`, were correct by chance. But my incorrect entry point didn't come up when I posted my fix for the issue, in 1:1s at work, or countless conversations leading up to this in-depth blog post. It only surfaced through rigorous re-telling and recreation of the journey.

Does it matter, though? Not for this bug. It was an input with no influence on the output. For this blog post, it _does_ matter, as I'd be confidently stating a wrong assumption about SPM build system. Or, if I contributed an "Overview of the build system" writeup. Maybe I would have caught it if I kept a detailed progress log, or if I happened to fix another issue in that area of code.

This experience, I believe, sheds light on the dual-headed danger and necessity of assumptions in debugging complex systems. It's easy to make assumptions about the behavior. I'd argue it's _necessary_ to make assumptions to survive the information overload, but _dangerous_ to not validate and re-check assumptions over time. I personally find remarkable clarity in creating visuals for my understanding, but how this manifests can vary: a talk, a Markdown doc, a whiteboarding session -- something that surfaces the implicit abstractions in code, and stratifies the cognitive understanding of the system from our individual encoding of its behavior.



## (Incorrectly) configuring the build system

<img src="/post-assets/spm-ios/spm-codebase-part1.png" class="overwidth" alt=""/>

## Starting the build system

<img src="/post-assets/spm-ios/spm-codebase-part2.png" class="overwidth" alt=""/>

## Initial checks just before running the build system


# Oh.

If one were to foolishly run this preposterous configuration on macOS 10.13, the following is observed:

<<snipppet showign spm dependency error>>

Sure, it's quirky that SPM infers defaults like that, but think back to our original command. We didn't _specify_ macOS. We specified _iOS_!

```sh
> swift build --triple arm64-apple-ios-simulator \
              --sdk "$(xcrun --sdk iphonesimulator --show-sdk-path)"
```

<div class="note">
    <p><i class="fa-solid fa-lightbulb"></i> SPM isn't respecting the platform inferred from `--triple` by the time we validate our dependencies.</p>
</div>

Where does Swift Package Manager validate dependencies?

```swift,hl_lines=9 13
// Sources/Build/BuildPlan.swift
static func validateDeploymentVersionOfProductDependency(
    product: ResolvedProduct,
    forTarget target: ResolvedTarget,
    observabilityScope: ObservabilityScope
) throws {
    // ...
    let productPlatform = product.platforms.getDerived(
        for: .macOS,
        usingXCTest: product.isLinkingXCTest
    )
    let targetPlatform = target.platforms.getDerived(
        for: .macOS,
        usingXCTest: target.type == .test
    )
    // ...
}
```

And its callsite:

```swift
// Sources/Build/BuildPlan.swift
public init(
    graph: ModulesGraph, /* ... */
) async throws {
    // ...
    try await Self.computeDestinations(
        graph: graph,
        onProduct: { product, destination in
            // [A]
        },
        onModule: { module, destination in
            // [B]
        )
    }
}
```

<describe entry point>

<describe A is not necessary>

As for `[B]`:

```swift,hl_lines=16
guard let package = graph.package(for: module) else {
    throw InternalError("Package not found for module: \(module.name)")
}

let buildParameters = destination == .host ? toolsBuildParameters : destinationBuildParameters

// Validate the product dependencies of this target.
for dependency in module.dependencies {
    guard dependency.satisfies(buildParameters.buildEnvironment) else {
        continue
    }

    switch dependency {
    case .module: break
    case .product(let product, _):
        if buildParameters.triple.isDarwin() {
            try BuildPlan.validateDeploymentVersionOfProductDependency(
                product: product,
                forTarget: module,
                observabilityScope: planningObservabilityScope
                        .makeChildScope(description: "Validate Deployment of Dependency")
                )
            }
        }
    }
}
```

What is `buildParameters.triple.isDarwin()`?

```swift
public func isDarwin() -> Bool {
    switch (vendor, os) {
    case (.apple, .noneOS):
        return false
    case (.apple, _), (_, .macosx), (_, .darwin):
        return true
    default:
        return false
    }
}
```






```sh
export TOOLCHAIN="/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2023-10-04-a.xctoolchain"
```
